## Script used for data pre-processing, sample integration and clustering
set.seed(11111)

setwd("C:/Users/ankita.lawarde/OneDrive - Tartu Ülikool/backup/scRNA-Seq_polyp_data/analysis")
outdir = "new_Samples_analysis"
options(future.globals.maxSize = 4000 * 1024^2)

################################ for filterred data from cell ranger ###################################
### fileterd data from cell ranger was used for data preprocessing.

# Load required libraries

library(SingleCellExperiment)
library(Seurat)
library(tidyverse)
library(Matrix)
library(scales)
library(cowplot)
library(RCurl)
#install.packages("remotes")
#remotes::install_github("chris-mcginnis-ucsf/DoubletFinder")
library(DoubletFinder)

######
##### We can compare these three samples (N3, N4 and N6) 
#with endometrial samples from our Sc-RNA sequencing polyp study, 
#which are H01, H21 and H33. 
#We can exclude H23 because very few cells were generated in this sample. 


##########################################################################################################
############################# Read data  #################################################################
# Step 1: Create a vector of convenient sample names, such as “A”, “B”, and “C”:
### H16 sample was clogged, and P23 showed very few cells. therefore, we have removed these 2 samples.

samples = c("H01", "H21", "H23", "H33", "P01", "P16", "P21", "P22", "P33")
#samples[1]

#Step 2: Read in the feature-barcode matrices generated by the cellranger pipeline
data.10x = list(); # first declare an empty list in which to hold the feature-barcode matrices

data.10x[[1]] <- Read10X(data.dir = "../output_Ankita/H01_output_intron/filtered_feature_bc_matrix")
data.10x[[2]] <- Read10X(data.dir = "../output_Ankita/H21_output_intron/filtered_feature_bc_matrix")
data.10x[[3]] <- Read10X(data.dir = "../output_Ankita/H23_output_intron/filtered_feature_bc_matrix")
data.10x[[4]] <- Read10X(data.dir = "../output_Ankita/H33_output_intron/filtered_feature_bc_matrix")
#data.10x

data.10x[[5]] <- Read10X(data.dir = "../output_Ankita/P01_output_intron/filtered_feature_bc_matrix")
data.10x[[6]] <- Read10X(data.dir = "../output_Ankita/P16_output_intron/filtered_feature_bc_matrix")
data.10x[[7]] <- Read10X(data.dir = "../output_Ankita/P21_output_intron/filtered_feature_bc_matrix")
data.10x[[8]] <- Read10X(data.dir = "../output_Ankita/P22_output_intron/filtered_feature_bc_matrix")
data.10x[[9]] <- Read10X(data.dir = "../output_Ankita/P33_output_intron/filtered_feature_bc_matrix")

data.10x


#Step 3: Convert each feature-barcode matrix to a Seurat object
scrna.list = list() # First create an empty list to hold the Seurat objects
scrna.list

for (i in 1:length(data.10x)) {
  scrna.list[[i]] = CreateSeuratObject(counts = data.10x[[i]], min.features=100, project=samples[i]);
  scrna.list[[i]][["DataSet"]] = samples[i];
}

scrna.list

#Step 4. Merge the Seurat objects into a single object
scrna <- merge(x=scrna.list[[1]], 
               y=c(scrna.list[[2]],
                   scrna.list[[3]], 
                   scrna.list[[4]],
                   scrna.list[[5]], 
                   scrna.list[[6]], 
                   scrna.list[[7]], 
                   scrna.list[[8]],
                   scrna.list[[9]]), 
               add.cell.ids = c("H01", "H21", "H23", "H33", "P01", "P16", "P21", "P22", "P33"), project="PolypData")

########################################################################################################
## remove the list created above to save memory
rm(scrna.list)
########################################################################################################


#######################################################################################################
# Check that the merged object has the appropriate sample-specific prefixes
head(scrna@meta.data)
tail(scrna@meta.data)

# Explore merged metadata
#View(scrna_cellranger@meta.data)


#########################################################################################################
## Step 5:
## The number of genes per UMI for each cell is quite easy to calculate, and 
## we will log10 transform the result for better comparison between samples.
## Add number of genes per UMI for each cell to metadata

scrna$log10GenesPerUMI <- log10(scrna$nFeature_RNA) / log10(scrna$nCount_RNA)


##########################################################################################################
## Step 6:
## Compute percent mito ratio

scrna$mitoRatio <- PercentageFeatureSet(object = scrna, pattern = "^MT-")
scrna$mitoRatio <- scrna@meta.data$mitoRatio / 100

## Step 7:
## compute percent ribosomal transcript ratio

scrna$riboRatio <- PercentageFeatureSet(object = scrna, pattern = "^RP[SL][[:digit:]]")
scrna$riboRatio <- scrna@meta.data$riboRatio / 100
#scrna$riboRatio

## check the metadata
head(scrna@meta.data)

## plots ###

pdf(sprintf("%s/VlnPlot.pdf", outdir), width = 13, height = 6);
vln <- VlnPlot(object = scrna, features = c("mitoRatio", "riboRatio"), pt.size=0, ncol = 2, group.by="DataSet");
print(vln);
dev.off();


scrna$nCount_RNA ## number of UMIs per cell
pdf(sprintf("%s/VlnPlot.nCount.25Kmax.pdf", outdir), width = 10, height = 10)
vln <- VlnPlot(object = scrna, features = "nCount_RNA", pt.size=0, group.by="DataSet", y.max=25000)
print(vln)
dev.off();

pdf(sprintf("%s/VlnPlot.nCount.allcount.pdf", outdir), width = 10, height = 10)
vln <- VlnPlot(object = scrna, features = "nCount_RNA", pt.size=0, group.by="DataSet")
print(vln)
dev.off();

#number of genes detected per cell
pdf(sprintf("%s/VlnPlot.nFeature.pdf", outdir), width = 10, height = 10)
vln <- VlnPlot(object = scrna, features = "nFeature_RNA", pt.size=0, group.by="DataSet")
print(vln)
dev.off()


pdf(sprintf("%s/Scatter1.pdf", outdir), width = 8, height = 6);
scatter <- FeatureScatter(object = scrna, feature1 = "nCount_RNA", feature2 = "mitoRatio", pt.size=0.1)
print(scatter);
dev.off()

pdf(sprintf("%s/Scatter2.pdf", outdir), width = 8, height = 6);
scatter <- FeatureScatter(object = scrna, feature1 = "nCount_RNA", feature2 = "riboRatio", pt.size=0.1)
print(scatter)
dev.off()

pdf(sprintf("%s/Scatter3.pdf", outdir), width = 8, height = 6);
scatter <- FeatureScatter(object = scrna, feature1 = "nCount_RNA", feature2 = "nFeature_RNA", pt.size=0.1)
print(scatter)
dev.off()



#######################################################################################################
### Create metadata dataframe #########################################################################
metadata <- scrna@meta.data
head(metadata)

#####################################################################################################
## Step 8:
## Create sample column  
metadata$sampleType <- NA
metadata$sampleType[which(str_detect(metadata$DataSet, "^H"))] <- "Healthy"
metadata$sampleType[which(str_detect(metadata$DataSet, "^P"))] <- "Polyps"

tail(metadata)
head(metadata)
head(scrna@meta.data)

## Step 9:
## Add metadata back to Seurat object
scrna@meta.data <- metadata
head(metadata)
head(scrna@meta.data)


# Visualize the number of cell counts per sample
metadata %>% 
  ggplot(aes(x=DataSet, fill=DataSet)) + 
  geom_bar() +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold")) +
  ggtitle("NCells")


head(metadata)
# Visualize the number UMIs/transcripts per cell
metadata %>% 
  ggplot(aes(color=DataSet, x=nCount_RNA, fill= DataSet)) + 
  geom_density(alpha = 0.2) + 
  scale_x_log10() + 
  theme_classic() +
  ylab("Cell density") +
  geom_vline(xintercept = 500)


# Visualize the distribution of genes detected per cell via histogram
metadata %>% 
  ggplot(aes(color=DataSet, x=nFeature_RNA, fill= DataSet)) + 
  geom_density(alpha = 0.2) + 
  theme_classic() +
  scale_x_log10() + 
  geom_vline(xintercept = 300)

# Visualize the distribution of genes detected per cell via boxplot
metadata %>% 
  ggplot(aes(x=DataSet, y=log10(nFeature_RNA), fill=DataSet)) + 
  geom_boxplot() + 
  theme_classic() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold")) +
  ggtitle("NCells vs NGenes")


# Visualize the correlation between genes detected and number of UMIs and determine whether strong presence of cells with low numbers of genes/UMIs
metadata %>% 
  ggplot(aes(x=nCount_RNA, y=nFeature_RNA, color=mitoRatio)) + 
  geom_point() + 
  scale_colour_gradient(low = "gray90", high = "black") +
  stat_smooth(method=lm) +
  scale_x_log10() + 
  scale_y_log10() + 
  theme_classic() +
  geom_vline(xintercept = 500) +
  geom_hline(yintercept = 250) +
  facet_wrap(~DataSet)

# Visualize the distribution of mitochondrial gene expression detected per cell
metadata %>% 
  ggplot(aes(color=DataSet, x=mitoRatio, fill=DataSet)) + 
  geom_density(alpha = 0.2) + 
  scale_x_log10() + 
  theme_classic() +
  geom_vline(xintercept = 0.2)


# Visualize the overall complexity of the gene expression by visualizing the genes detected per UMI
metadata %>%
  ggplot(aes(x=log10GenesPerUMI, color = DataSet, fill=DataSet)) +
  geom_density(alpha = 0.2) +
  theme_classic() +
  geom_vline(xintercept = 0.8)


table(scrna@meta.data$DataSet)

#H01  H21  H22  H33  P01  P16  P21  P22  P33 
#4087 1556  199 1752 1848 2431 2809  647 1067

#######################################################################################################
# Filter out low quality reads using selected thresholds - these will change with experiment
#######################################################################################################
## Step 10:

summary(metadata$nCount_RNA)
summary(metadata$nFeature_RNA)
summary(metadata$log10GenesPerUMI)
summary(metadata$mitoRatio)
summary(metadata$riboRatio)

filtered_seurat <- subset(x = scrna, 
                          subset= log10GenesPerUMI > 0.80)


summary(filtered_seurat$log10GenesPerUMI)

dev.off()

# Visualize the overall complexity of the gene expression by visualizing the genes detected per UMI
metadata %>%
  ggplot(aes(x=log10GenesPerUMI, color = DataSet, fill=DataSet)) +
  geom_density(alpha = 0.2) +
  theme_classic() +
  geom_vline(xintercept = 0.8)

#########################################################################################################
## Step 11:
## Gene-level filtering
# Output a logical vector for every gene on whether the more than zero counts per cell
# Extract counts
counts <- GetAssayData(object = filtered_seurat, slot = "counts")
counts

# Output a logical vector for every gene on whether the more than zero counts per cell
nonzero <- counts > 0
nonzero

# Sums all TRUE values and returns TRUE if more than 3 TRUE values per gene
keep_genes <- Matrix::rowSums(nonzero) >= 3
table(keep_genes)

# Only keeping those genes expressed
filtered_counts <- counts[keep_genes, ]
head(filtered_seurat@meta.data)

# Reassign to filtered Seurat object
filtered_seurat <- CreateSeuratObject(filtered_counts, meta.data = filtered_seurat@meta.data)


# Save filtered subset to new metadata
metadata_clean <- filtered_seurat@meta.data
head(metadata_clean)

# Visualize the overall complexity of the gene expression by visualizing the genes detected per UMI
metadata_clean %>%
  ggplot(aes(x=log10GenesPerUMI, color = DataSet, fill=DataSet)) +
  geom_density(alpha = 0.2) +
  theme_classic() +
  geom_vline(xintercept = 0.8)

dev.off()

table(filtered_seurat@meta.data$DataSet)

#H01  H21  H22  H33  P01  P16  P21  P22  P33 
#4034 1305  189 1685 1694 2268 2614  575 1033 

# Create .RData object to load at any time
save(filtered_seurat, file="seurat_filtered_cellranger.RData")
#load("seurat_filtered_cellranger.RData")

## edit metadata
filtered_seurat
filtered_seurat@meta.data
filtered_seurat@meta.data$orig.ident <- gsub("H22", "H23", filtered_seurat@meta.data$orig.ident)
filtered_seurat@meta.data$DataSet <- gsub("H22", "H23", filtered_seurat@meta.data$DataSet)

factor(filtered_seurat@meta.data$orig.ident)
filtered_seurat@active.ident
factor(filtered_seurat@meta.data$DataSet)


####################### Check cell cycle genes #######################################################
#Step 12. Calculate a cell cycle score for each cell
cell.cycle.tirosh <- read.csv("http://genomedata.org/rnaseq-tutorial/scrna/CellCycleTiroshSymbol2ID.csv", header=TRUE); # read in the list of genes
cell.cycle.tirosh
s.genes = cell.cycle.tirosh$Gene.Symbol[which(cell.cycle.tirosh$List == "G1/S")]; # create a vector of S-phase genes
s.genes
g2m.genes = cell.cycle.tirosh$Gene.Symbol[which(cell.cycle.tirosh$List == "G2/M")]; # create a vector of G2/M-phase genes


#Cell cycle scoring

# Normalize the counts
seurat_phase <- NormalizeData(filtered_seurat)

# Score cells for cell cycle
seurat_phase <- CellCycleScoring(seurat_phase, 
                                 g2m.features = g2m.genes, 
                                 s.features = s.genes)

# View cell cycle scores and phases assigned to cells                                 
View(seurat_phase@meta.data)       

# Identify the most variable genes
seurat_phase <- FindVariableFeatures(seurat_phase, 
                                     selection.method = "vst",
                                     nfeatures = 2000, 
                                     verbose = FALSE)

# Scale the counts
seurat_phase <- ScaleData(seurat_phase)

# Perform PCA
seurat_phase <- RunPCA(seurat_phase)

# Plot the PCA colored by cell cycle phase
DimPlot(seurat_phase,
        reduction = "pca",
        group.by= "Phase",
        split.by = "Phase")


DimPlot(seurat_phase, 
        reduction = "pca",
        group.by = "Phase")

###########################################################################################################
## Step 13:
# Split seurat object by condition to perform cell cycle scoring and SCT on all samples

split_seurat <- SplitObject(filtered_seurat, split.by = "orig.ident")
split_seurat

split_seurat <- split_seurat[c("H01", "H21", "H22", "H33", "P01", "P16", "P21", "P22", "P33")]

for (i in 1:length(split_seurat)) {
  split_seurat[[i]] <- NormalizeData(split_seurat[[i]], verbose = TRUE)
  split_seurat[[i]] <- CellCycleScoring(split_seurat[[i]], g2m.features = g2m.genes, s.features = s.genes)
  split_seurat[[i]] <- SCTransform(split_seurat[[i]], vars.to.regress = c("mitoRatio"))
}

split_seurat

## save filtered and normalized data
saveRDS(split_seurat, file = "split_seurat.rds")

#split_seurat <- readRDS(file = "split_seurat.rds")


#########################################################################################################
## Step 14:
## run doubletfinder
## loop through samples to find doublets
###########################################################################################################

library(parallel)

for (i in 1:length(split_seurat)) {
  # print the sample we are on
  print(paste0("Sample ",i))
  sample <- split_seurat[[i]]
  sample <- RunPCA(sample, nfeatures.print = 10)
  
  # Find significant PCs
  stdv <- sample[["pca"]]@stdev
  sum.stdv <- sum(sample[["pca"]]@stdev)
  percent.stdv <- (stdv / sum.stdv) * 100
  cumulative <- cumsum(percent.stdv)
  co1 <- which(cumulative > 90 & percent.stdv < 5)[1]
  co2 <- sort(which((percent.stdv[1:length(percent.stdv) - 1] - 
                       percent.stdv[2:length(percent.stdv)]) > 0.1), 
              decreasing = T)[1] + 1
  min.pc <- min(co1, co2)
  min.pc
  
  # finish pre-processing
  sample <- RunUMAP(sample, dims = 1:min.pc)
  sample <- FindNeighbors(object = sample, dims = 1:min.pc)              
  sample <- FindClusters(object = sample, resolution = 0.1)
  
  # pK identification (no ground-truth)
  sweep.list <- paramSweep(sample, PCs = 1:min.pc, sct = TRUE)
  sweep.stats <- summarizeSweep(sweep.list)
  bcmvn <- find.pK(sweep.stats)
  
  # Optimal pK is the max of the bomodality coefficent (BCmvn) distribution
  bcmvn.max <- bcmvn[which.max(bcmvn$BCmetric),]
  optimal.pk <- bcmvn.max$pK
  optimal.pk <- as.numeric(levels(optimal.pk))[optimal.pk]
  
  ## Homotypic doublet proportion estimate
  annotations <- sample@meta.data$seurat_clusters
  homotypic.prop <- modelHomotypic(annotations) 
  nExp.poi <- round(optimal.pk * nrow(sample@meta.data)) ## Assuming 1.6% doublet formation rate - tailor for your dataset
  nExp.poi.adj <- round(nExp.poi * (1 - homotypic.prop))
  
  # run DoubletFinder
  sample <- doubletFinder(seu = sample,
                             PCs = 1:min.pc, 
                             pK = optimal.pk,
                             nExp = nExp.poi.adj, sct = TRUE)
  
  metadata <- sample@meta.data
  dim(metadata)
  colnames(metadata)[length(colnames(metadata))] <- "doublet_finder"
  sample@meta.data <- metadata 
  
  # subset and save
  singlets <- subset(sample, doublet_finder == "Singlet")
  split_seurat[[i]] <- singlets
  remove(singlets)
}


## check the metadata after doubletFinder
split_seurat[[1]]@meta.data
dim(split_seurat[[1]]@meta.data)
split_seurat[[1]]@meta.data
split_seurat[[1]]@assays
length(colnames(split_seurat[[1]]@meta.data))
colnames(split_seurat[[1]]@meta.data)
head(split_seurat[[1]]@meta.data[length(colnames(split_seurat[[1]]@meta.data))])

############################################################################################
#remove all predicted doublets from our data.
for (i in 1:length(split_seurat)) {
  split_seurat[[i]] = split_seurat[[i]][,split_seurat[[i]]@meta.data[,17] == "Singlet"]
}
split_seurat

## save data after doubletfinder
saveRDS(split_seurat, file = "spli_seurat_SCT_afterdoubletFinder.rds")

#######################################################################################################

### load the doubelt removed data
split_seurat <- readRDS(file = "spli_seurat_SCT_afterdoubletFinder.rds")

split_seurat
table(split_seurat$H01@meta.data$DataSet)
table(split_seurat$H21@meta.data$DataSet)
table(split_seurat$H22@meta.data$DataSet)
table(split_seurat$H33@meta.data$DataSet)
table(split_seurat$P01@meta.data$DataSet)
table(split_seurat$P16@meta.data$DataSet)
table(split_seurat$P21@meta.data$DataSet)
table(split_seurat$P22@meta.data$DataSet)
table(split_seurat$P33@meta.data$DataSet)

# Check which assays are stored in objects, select anyone sample
split_seurat$H01@reductions


### Intgarte 8 samples ##################################################################
## Step 15:
# Select the most variable features to use for integration
integ_features <- SelectIntegrationFeatures(object.list = split_seurat, 
                                            nfeatures = 3000) 


integ_features

## Step 16:
# Prepare the SCT list object for integration
split_seurat <- PrepSCTIntegration(object.list = split_seurat, 
                                   anchor.features = integ_features)

## Step 17:
# Find best buddies - can take a while to run
integ_anchors <- FindIntegrationAnchors(object.list = split_seurat, 
                                        normalization.method = "SCT", 
                                        anchor.features = integ_features)


integ_anchors

## Step 18:
## Integrate across conditions
seurat_integrated <- IntegrateData(anchorset = integ_anchors, 
                                   normalization.method = "SCT")


# Save integrated seurat object
saveRDS(seurat_integrated, file = "seurat_integrated_polypData.rds")

seurat_integrated <- readRDS(file = "seurat_integrated_polypData.rds")
seurat_integrated


###############################################################################################
############# cell clustering #################################################################

# Select the RNA counts slot to be the default assay
#DefaultAssay(seurat_integrated) <- "RNA"

# Normalize RNA data for visualization purposes
#seurat_integrated <- NormalizeData(seurat_integrated, verbose = FALSE)

#seurat_integrated@assays

#seurat_counts <- GetAssayData(object = seurat_integrated, slot = "counts")
#seurat_counts
#dim(seurat_counts)

#write.table(seurat_counts, file = "polypdata_9_samples_count_matrix.txt")


# Run PCA
seurat_integrated <- RunPCA(object = seurat_integrated)

# Plot PCA
PCAPlot(seurat_integrated,
        group.by = "sampleType", split.by = "sampleType")  

seurat_integrated@reductions
# Run UMAP
seurat_integrated <- RunUMAP(seurat_integrated, 
                             dims = 1:50,
                             reduction = "pca")

# Plot UMAP                             
DimPlot(seurat_integrated)
DimPlot(seurat_integrated, group.by = "DataSet", split.by = "sampleType")
DimPlot(seurat_integrated, split.by = "sampleType")
DimPlot(seurat_integrated, split.by = "DataSet")



# Explore heatmap of PCs
DimHeatmap(seurat_integrated, 
           dims = 1:10, 
           cells = 500, 
           balanced = TRUE)

# Printing out the most variable genes driving PCs
print(x = seurat_integrated[["pca"]], 
      dims = 1:10, 
      nfeatures = 5)


# Plot the elbow plot
ElbowPlot(object = seurat_integrated, 
          ndims = 40)


# Determine percent of variation associated with each PC
pct <- seurat_integrated[["pca"]]@stdev / sum(seurat_integrated[["pca"]]@stdev) * 100
pct

# Calculate cumulative percents for each PC
cumu <- cumsum(pct)
cumu

# Determine which PC exhibits cumulative percent greater than 90% and % variation associated with the PC as less than 5
co1 <- which(cumu > 90 & pct < 5)[1]

co1


# Determine the difference between variation of PC and subsequent PC
co2 <- sort(which((pct[1:length(pct) - 1] - pct[2:length(pct)]) > 0.1), decreasing = T)[1] + 1

# last point where change of % of variation is more than 0.1%.
co2

# Minimum of the two calculation
pcs <- min(co1, co2)

pcs

# Create a dataframe with values
plot_df <- data.frame(pct = pct, 
                      cumu = cumu, 
                      rank = 1:length(pct))

# Elbow plot to visualize 
ggplot(plot_df, aes(cumu, pct, label = rank, color = rank > pcs)) + 
  geom_text() + 
  geom_vline(xintercept = 90, color = "grey") + 
  geom_hline(yintercept = min(pct[pct > 5]), color = "grey") +
  theme_bw()


# Determine the K-nearest neighbor graph
seurat_integrated <- FindNeighbors(object = seurat_integrated, 
                                   dims = 1:50)

seurat_integrated
seq(0.2,1.4,by = 0.1)

# Determine the clusters for various resolutions                                
seurat_integrated <- FindClusters(object = seurat_integrated,
                                  resolution = seq(0.2,1.4, by = 0.1))

suppressMessages(require(clustree))
clustree(seurat_integrated)

# Explore resolutions
seurat_integrated@meta.data %>% 
  View()

############## save the data after findcluster. ############################################################
## This is the final pre-processed, integrated and clustered data

saveRDS(seurat_integrated, file = "clusters_polypdata_integrated_from_0.2.rds")

###########################################################################################################


### Visualizations ##########################################################################################
## load the pre-processed , integrated and clusters identified saved data 

seurat_integrated <- readRDS(file = "clusters_polypdata_integrated_from_0.2.rds")
seurat_integrated

# Assign identity of clusters : 
#Idents(object = seurat_integrated) <- "integrated_snn_res.0.2"
#Idents(object = seurat_integrated) <- "integrated_snn_res.0.3"
Idents(object = seurat_integrated) <- "integrated_snn_res.0.4"
#Idents(object = seurat_integrated) <- "integrated_snn_res.0.5"
#Idents(object = seurat_integrated) <- "integrated_snn_res.0.6"

seurat_integrated@meta.data
seurat_integrated@meta.data$orig.ident
seurat_integrated@meta.data$orig.ident <- gsub("H22", "H23", seurat_integrated@meta.data$orig.ident)
seurat_integrated@meta.data$DataSet <- gsub("H22", "H23", seurat_integrated@meta.data$DataSet)

factor(seurat_integrated@meta.data$orig.ident)
seurat_integrated@active.ident
factor(seurat_integrated@meta.data$DataSet)


# Plot the UMAP
DimPlot(seurat_integrated,
        reduction = "umap",
        label = TRUE,
        label.size = 6, split.by = "sampleType")


# Extract identity and sample information from seurat object to determine the number of cells per cluster per sample
n_cells <- FetchData(seurat_integrated, 
                     vars = c("ident", "orig.ident")) %>%
  dplyr::count(ident, orig.ident) %>%
  tidyr::spread(ident, n)

# View table
View(n_cells)



write.csv(n_cells, file = paste0(outdir, "/n_cell_in_clusters.csv"))

saveRDS(seurat_integrated, file = "clusters_polypdata_integrated_from_0.2_corrected.rds")
seurat_integrated <- readRDS(file = "clusters_polypdata_integrated_from_0.2_corrected.rds")

table(seurat_integrated@meta.data$DataSet)
seurat_integrated

# UMAP of cells in each cluster by sample
DimPlot(seurat_integrated, 
        label = TRUE, 
        split.by = "sampleType")  + NoLegend()

DimPlot(seurat_integrated, 
        label = TRUE, 
        split.by = "DataSet")  + NoLegend()


# Explore whether clusters segregate by cell cycle phase
DimPlot(seurat_integrated,
        label = TRUE, 
        split.by = "Phase")  + NoLegend()

# Determine metrics to plot present in seurat_integrated@meta.data
metrics <-  c("nCount_RNA", "nFeature_RNA", "S.Score", "G2M.Score", "mitoRatio")

FeaturePlot(seurat_integrated, 
            reduction = "umap", 
            features = metrics,
            pt.size = 0.4, 
            order = TRUE,
            min.cutoff = 'q10',
            label = TRUE)


seurat_integrated


#############################################################################
#Identification of all markers for each cluster
# find markers from clusters by wilcox test analysis
markerswilcox <- FindAllMarkers(object = seurat_integrated, 
                                only.pos = FALSE,
                                logfc.threshold = 0.25)


outdir
save(markerswilcox, file = paste0(outdir, "/markerswilcoxtest.RData"))

################################################ 
## subste the DEGs from the wilcox method

load(file = paste0(outdir, "/markerswilcoxtest.RData"))

dim(markerswilcox)

head(markerswilcox)

markerswilcox <- markerswilcox[abs(markerswilcox$avg_log2FC) > 0.5 & markerswilcox$p_val_adj < 0.05,]
dim(markerswilcox)
min(markerswilcox$avg_log2FC)

## add all marker genes to the marker file
paper_marker <- readxl::read_excel(path = "cell_marker_frommapping_paper.xlsx", sheet = "epithelial_subpopulation")
dim(paper_marker)
head(paper_marker)

one_list <- paper_marker[,c(5,6)]
head(one_list)

markerstype <- markerswilcox %>%
  left_join(y = unique(one_list),
            by = c("gene" = "gene3"))


head(markerstype)


## concatenate back all cell type into a single entry seprated by comma
library(plyr)
concat_df <- ddply(markerstype, .(p_val, avg_log2FC, pct.1, pct.2, p_val_adj, cluster.x, gene), 
                   summarise, cluster.y = list(cluster.y)) 

head(concat_df)
dim(concat_df)

dim(concat_df[concat_df$cluster.x == 0,])
concat_df <- data.frame(concat_df)
head(concat_df)


head(concat_df$cluster.y)
length(concat_df$cluster.y)
matrix(unlist(concat_df$cluster.y))
names(concat_df$cluster.y)

cluster.y <- plyr::ldply(concat_df$cluster.y, rbind)
head(cluster.y)
cluster.y <- cluster.y %>%
  tidyr::unite(col = "unitedcol", 1:13, sep = ",")

cluster.y$unitedcol

concat_df$cluster.y <- cluster.y$unitedcol

writexl::write_xlsx(concat_df, path = "adj_pval_lfc_maerkertype.xlsx")
writexl::write_xlsx(cluster.y, path = "clustercell_type.xlsx")

## top20 DEGS from clusters
top20_wilcox <- concat_df %>%
  group_by(cluster.x) %>% 
  top_n(n = 20, 
        wt = avg_log2FC)


top20_wilcox

writexl::write_xlsx(top20_wilcox, path = paste0(outdir, "/top20_DEGS_by_clusters.xlsx"))


#################################################
## Find markers by roc method
markerswilcox <- FindAllMarkers(object = seurat_integrated, 
                                test.use = "roc",
                                only.pos = FALSE,
                                logfc.threshold = 0.25)


markerswilcox
markerroc <- markerswilcox

save(markerroc, file = paste0(outdirP, "/markerroc.RData"))

#################################################################################################################################################
